"""
Signal Model

Represents a trading signal generated by a strategy.
"""

from datetime import datetime
from decimal import Decimal
from typing import Any, Optional

from pydantic import BaseModel, Field, field_validator

from src.domain.models.enums import MarketType, SignalAction, Timeframe


class Signal(BaseModel):
    """
    Trading signal generated by a strategy.
    
    A signal represents a strategy's recommendation to take action
    on a specific symbol. Signals are validated, aggregated, and
    optionally executed by the system.
    
    Attributes:
        strategy_id: Unique identifier of the strategy that generated this signal
        timestamp: When the signal was generated
        symbol: Trading pair/symbol (e.g., "BTCUSDT", "EUR_USD")
        market_type: Type of market (crypto, forex, stock)
        action: Recommended action (BUY, SELL, HOLD, CLOSE)
        position_size: Size as fraction of allocated capital (0.0-1.0)
        entry_price: Suggested entry price (None for market orders)
        stop_loss: Stop-loss price level
        take_profit: Take-profit price level
        confidence: Strategy's confidence in this signal (0.0-1.0)
        timeframe: Chart timeframe this signal is based on
        metadata: Additional data for logging/analysis
    """
    
    strategy_id: str = Field(..., min_length=1, description="Strategy identifier")
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    symbol: str = Field(..., min_length=1, description="Trading symbol")
    market_type: MarketType = Field(..., description="Market type")
    action: SignalAction = Field(..., description="Signal action")
    
    # Position sizing
    position_size: float = Field(
        default=0.0,
        ge=0.0,
        le=1.0,
        description="Position size as fraction of capital (0-1)"
    )
    
    # Price levels
    entry_price: Optional[Decimal] = Field(
        default=None,
        description="Entry price (None for market orders)"
    )
    stop_loss: Optional[Decimal] = Field(
        default=None,
        description="Stop-loss price"
    )
    take_profit: Optional[Decimal] = Field(
        default=None,
        description="Take-profit price"
    )
    
    # Confidence and context
    confidence: float = Field(
        default=0.5,
        ge=0.0,
        le=1.0,
        description="Signal confidence (0-1)"
    )
    timeframe: Timeframe = Field(
        default=Timeframe.H1,
        description="Timeframe the signal is based on"
    )
    
    # Extensible metadata
    metadata: dict[str, Any] = Field(
        default_factory=dict,
        description="Additional signal metadata"
    )
    
    @field_validator("position_size")
    @classmethod
    def validate_position_size(cls, v: float, info) -> float:
        """Ensure HOLD signals have zero position size."""
        # Access other fields via info.data
        action = info.data.get("action")
        if action == SignalAction.HOLD and v > 0:
            return 0.0
        return v
    
    @property
    def is_actionable(self) -> bool:
        """Check if signal requires action (not HOLD)."""
        return self.action != SignalAction.HOLD
    
    @property
    def is_entry(self) -> bool:
        """Check if signal is an entry (BUY or SELL)."""
        return self.action in (SignalAction.BUY, SignalAction.SELL)
    
    @property
    def is_exit(self) -> bool:
        """Check if signal is an exit (CLOSE)."""
        return self.action == SignalAction.CLOSE
    
    @property
    def risk_reward_ratio(self) -> Optional[float]:
        """Calculate risk/reward ratio if stop-loss and take-profit are set."""
        if not all([self.entry_price, self.stop_loss, self.take_profit]):
            return None
        
        entry = float(self.entry_price)
        sl = float(self.stop_loss)
        tp = float(self.take_profit)
        
        risk = abs(entry - sl)
        reward = abs(tp - entry)
        
        if risk == 0:
            return None
        
        return reward / risk
    
    def __str__(self) -> str:
        return (
            f"Signal({self.strategy_id}: {self.action.value} {self.symbol} "
            f"@ {self.confidence:.0%} confidence)"
        )
